"""
<Time Complexity>

시간복잡도는 입력값과 문제를 해결하는 데 걸리는 시간과의 상관관계를 말합니다!
입력값이 2배로 늘어났을 때 문제를 해결하는 데 걸리는 시간은 몇 배로 늘어나는지를 보는 것이죠.
우리는 시간이 적게 걸리는 알고리즘을 좋아하니 입력값이 늘어나도 걸리는 시간이 덜 늘어나는 알고리즘이 좋은 알고리즘이겠죠?
"""

def find_max_num(array):
    for number in array:
        is_max_num = True
        for compare_number in array:
            if number < compare_number:
                is_max_num = False
        if is_max_num:
            return number

print("정답 = 6 / 현재 풀이 값 = ", find_max_num([3, 5, 6, 1, 2, 4]))
print("정답 = 6 / 현재 풀이 값 = ", find_max_num([6, 6, 6]))
print("정답 = 1888 / 현재 풀이 값 = ", find_max_num([6, 9, 2, 7, 1888]))

"""
 이 해결 방법은 각 숫자마다 모든 다른 숫자와 비교해서 최대값인지 확인합니다. 만약 다른 모든 값보다 크다면 반복문을 중단합니다.
 이 함수가 시간이 얼마나 걸리는지 어떻게 분석할 수 있을까요?
 바로, **각 줄이 실행되는 걸 1번의 연산이 된다**고 생각하고 계산하시면 됩니다. 아래와 같이 계산할 수 있습니다.
 """

"""
    위에서 연산된 것들을 더해보면,
    1. array의 길이 X array의 길이 X (비교 연산 1번 + 대입 연산 1번)
    만큼의 시간이 필요합니다. 여기서 array(입력값)의 길이는 보통 N이라고 표현합니다. 그러면 위의 시간을 다음과 같이 표현할 수 있습니다
        
        N * N *2

    2. array의 길이 X 비교 연산 1번 만큼의 시간이 필요합니다.
        N
    
        
        그러면 우리는 이제 이 함수는  2* N^2 + N 만큼의 시간이 걸렸겠구나! 라고 말할 수 있습니다.




Q. 선생님 여기서 입력값이 뭔가요?
A. 함수에서 크기가 변경될 수 있는 값이라고 보시면 됩니다! 
배열을 받고 있으니 이 함수에서는 배열이 입력값입니다.

Q. 선생님 그러면 여기서 N 이 6이니까, 78이라고 말하면 안되나요?
A. N 의 크기에 따른 시간의 상관관계를 시간복잡도라고 하는 것이라 수식으로 표현하셔야 합니다!

두 번째 방법

"""

def find_max_num(array):
    max_number = array[0]

    for number in array:
        if number > max_number:
            max_number = number
    return max_number




print("정답 = 6 / 현재 풀이 값 = ", find_max_num([3, 5, 6, 1, 2, 4]))
print("정답 = 6 / 현재 풀이 값 = ", find_max_num([6, 6, 6]))
print("정답 = 1888 / 현재 풀이 값 = ", find_max_num([6, 9, 2, 7, 1888]))

"""""
비교하기


코드만 봐도 두 번째 방법이 좋을 것 같다고 어렴풋이 생각은 했겠지만, 이렇게 수치화시키니 얼마나 효율적인지 정량적으로 분석할 수 있습니다
그러면, 이를 수학적으로 표현해보면 첫 번째 방법은 2 * N^2 + N, 두 번째 방법은 2N+1 이라는 식이 나온다는 걸 알 수 있습니다.
그러면 N 의 길이가 길어질수록, 다음과 같이 연산량이 변화합니다.

1.  N 과 N^2 은 N 이 커질수록 더 큰 차이가 나는구나!
2.  N의 지수를 먼저 비교하면 되겠구나

- 저희가 매번 코드를 매 실행 단위로 이렇게 몇 번의 연산이 발생하는지 확인하는 건 불가능합니다. 
  따라서 **상수는 신경쓰지말고**, 입력값에 비례해서 어느 정도로 증가하는지만 파악하면 됩니다.

즉,
2N^2 + N의 연산량이 나온 첫번째 풀이 방법은 $N^2$ 만큼의 연산량이 필요하다.
2N+1의 연산량이 나온 두번째 풀이 방법은 $N$ 만큼의 연산량이 필요하다

참고로, 만약 상수의 연산량이 필요하다면, $1$ 만큼의 연산량이 필요하다고 말하면 됩니다. 


"""

